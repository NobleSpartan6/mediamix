This document guides an AI coding agent (or developer) in rebuilding the MediaMix timeline UI into a professional-grade browser-based video editor. The current timeline implementation is incomplete/broken, so we will reconstruct core features from scratch with a clear structure and scope. Follow the instructions below to focus on the right components, implement essential features, adhere to style guidelines, and validate the changes for a polished, functional timeline.
Scope and Focus Areas
Work will be concentrated in the timeline UI and related state management. Key areas and files to target:
Timeline UI Components: Rebuild the timeline interface in the React components under apps/web/src/features/timeline/components. In particular, focus on:
Timeline.tsx – the main timeline container (holds tracks, ruler, playhead, etc.).
TrackRow.tsx – represents a single track lane (video or audio) and contains clip elements.
InteractiveClip.tsx – wraps a Clip with interactive behavior (dragging, trimming).
Clip.tsx – the visual representation of a clip (styled block with proper width, color, and trim handles).
Also review utility components like TimeRuler.tsx (timecode ruler with ticks) and Playhead.tsx (vertical playhead indicator). These may need enhancements to integrate with the new timeline logic.
State Management (Zustand stores): Use and possibly extend the Zustand stores:
timelineStore.ts – holds timeline state (clip list, timeline duration, beats, etc.) and provides functions to add/update clips. All timeline modifications (adding clips, moving or splitting clips, etc.) should be done through this store’s API (e.g. setClips, addClip, updateClip)
file-shxvswtzmkesdt1ecpwdnp
. Keep state logic here, decoupled from UI, to facilitate future collaboration features (the project plans to integrate CRDT/Yjs for multi-user editing).
mediaStore.ts – if not already present, create or update a media store to manage media assets. This store can hold loaded media files’ info (duration, waveform data, thumbnails) and any state needed for preview rendering. The timeline will pull data from here as needed (e.g. to display waveforms or image thumbnails for clips).
Rendering Logic for Waveforms & Thumbnails: Implement the groundwork for audio waveforms and video thumbnails on clips:
For audio clips/tracks, generate a waveform visualization so users can see audio peaks. This may involve analyzing audio data (e.g. using Web Audio API or OfflineAudioContext to get waveform buffers) and drawing the waveform. Aim to use an efficient rendering method (e.g. drawing to a <canvas> for each audio clip’s waveform) rather than DOM elements for thousands of peaks, to maintain performance. You can prepare waveform data when media is loaded (store an array of peaks in mediaStore) and then render that in the clip UI (possibly as a canvas or an SVG path).
For video clips, show a thumbnail or preview frame on the clip element. A simple approach for now is to extract the first frame (or a representative frame) of the video and display it (e.g. as an <img> background on the clip, or drawn on a canvas). Ensure this is done efficiently (e.g. using the Video element’s captureImage() or drawing a frame to canvas) and consider lazy-loading or downsampling for performance. If implementing in this iteration is too complex, you can stub the thumbnail with a generic icon or color, but leave hooks to replace it with real previews soon.
Both waveforms and thumbnails should fit within the clip container (respect clip start, end, width) and update if the clip is trimmed. Keep their rendering optimized (no re-drawing on every frame unnecessarily) – e.g., render once when clip is added or when zoom level changes significantly.
By focusing on the above components and stores, the agent will rebuild the timeline’s foundation. Next, we outline the core features that must be implemented in this rebuild.
Foundational Features to Implement
The timeline should be rebuilt with the following core features and behaviors:
Dynamic Multi-Lane Tracks (Video/Audio per Asset): Support a timeline with multiple tracks (lanes) that can represent separate media assets. Each imported media file (with video and audio) should occupy its own set of timeline tracks: for example, a video file would create a video track lane and an audio track lane. The timeline should render these lanes stacked vertically and labeled accordingly (e.g. V1 for the first video track, A1 for its audio, V2 for the next video, A2 for that audio, etc.). Ensure the track list is generated from the clip data in state – if two clips are on different lanes, two track rows are shown. The layout must handle an arbitrary number of tracks (scroll vertically if there are many). Each track row should have a consistent height (e.g. video tracks taller than audio tracks) and a clear separator or border between tracks. (In the current MVP code, laneIndex === 0 was treated as video and others as audio; in the new implementation, adjust this logic to correctly label multiple video lanes.) Tracks may include a left-side label area (e.g., showing “V1”, “A1”) for identification and future track controls (mute/lock buttons can be stubbed for now).
Sticky Timecode Ruler with Tick Marks & Beat Lines: Implement a persistent time ruler at the top of the timeline that shows time markings. This ruler should stay aligned with the timeline content and remain visible as you scroll horizontally (sticky behavior). Major tick marks (e.g. every second) should span the full height of the ruler, with numeric labels at those positions
github.com
github.com
. Minor tick marks (sub-second, e.g. frame-level at 30fps) should be drawn as shorter lines between major ticks when zoomed in sufficiently
github.com
. Use the current zoom (pixels per second) to space these ticks appropriately. The ruler should dynamically update as the user scrolls or zooms – only the visible time range needs to be rendered at any given moment (use an efficient method to compute visible ticks, e.g. as done in the existing TimeRuler component with requestAnimationFrame throttling
github.com
github.com
). In addition to time ticks, if beat markers are available (the timelineStore has a beats array of timestamps), draw vertical indicator lines for those beats across the ruler (and possibly extending down the track area)
github.com
. Beat lines help align edits to music; render them in a distinct style (e.g. a subtle accent-colored line or a lighter overlay) so they’re visible but not distracting. The ruler should use a monospace font for timecode, and format times into MM:SS.ff or similar if needed (for now, seconds with maybe frame fraction is acceptable). Ensure the ruler’s background and tick colors match the design (dark background, ticks in gray, text in lighter gray for contrast).
GPU-Accelerated Clip Rendering (Positioning, Dragging, Trimming): Each clip on the timeline represents a media segment that can be moved or resized. Implement clip rendering and interaction such that it remains performant:
Position & Size: Render each clip as an absolutely positioned element within its track, with a width proportional to its duration and an X-offset according to its start time. Use CSS transforms (translateX) for horizontal positioning, and update the width via style – this leverages GPU compositing for moves and avoids reflows when dragging clips
github.com
. Do not use CSS left or margins for positioning clips, as those would trigger layout recalculations and hurt performance. The Clip component (or equivalent) should apply the transform and width based on the clip’s start and end times from state. Include visible trim handles at the left and right edges of the clip (small draggable areas) to indicate the user can resize the clip duration
github.com
 (the codebase already includes divs for handles).
Dragging: Users should be able to grab a clip and drag it left or right along the timeline to reposition it in time. Integrate a library like react-moveable (already imported in the code) or use pointer events to handle the drag. On drag start, record the clip’s original start position; on drag move, update the clip’s visual position in real-time (via transform) following the cursor; on drag end, commit the new start (and end) times to the state via timelineStore.updateClip(...)
github.com
github.com
. Constrain dragging to horizontal movement (no vertical move between tracks in this phase, unless implementing track reordering later). If a clip hits the timeline start (0) or overlaps another clip’s region, you might prevent further drag in that direction (or we can allow overlap for now if the model supports multiple clips on one track).
Trimming/Resizing: Enable adjusting the in/out point of a clip by dragging its edges. Using react-moveable, you can make the clip resizable on the horizontal axis (renderDirections={['w','e']} for west/east handles)
github.com
. On resize, as the handle is dragged, update the clip’s width (and if the left edge is dragged, also its translateX position) in real-time to follow the handle
github.com
github.com
. On resize end, calculate the new start or end time based on the final size and commit it to state
github.com
github.com
. This allows users to trim the clip shorter or extend it (up to its media’s length – ensure not to allow beyond the source’s duration if that data is available).
Visual Feedback & Selection: As these interactions are implemented, ensure there’s clear visual feedback. The clip being dragged or trimmed could show a subtle highlight or its border in the accent color if focused/active. The playhead can also be used as a reference (e.g., user might align a clip’s start to the playhead). For now, a single selected clip highlight is enough – full multi-select or ripple editing can come later. All of these interactions should feel smooth at 60fps, so use techniques like requestAnimationFrame batching and limit heavy computations during drag (only update state on end, not continuously, to avoid React re-renders mid-drag). The combination of using transforms and batching DOM writes should help maintain performance.
Trackpad/Mouse Pan & Zoom Controls: Make the timeline navigable with intuitive pan and zoom gestures:
Horizontal Panning: Users should be able to scroll the timeline horizontally both with pointer drag and with trackpad/mouse wheel. Implement click-and-drag panning on the track area (e.g., by handling pointer down/move on the scroll container). When the user drags the timeline (or uses a trackpad swipe), move the scroll position accordingly. Include momentum/inertia: when the user releases a drag, continue scrolling for a brief moment based on velocity, gradually decelerating
github.com
. The provided useZoomScroll hook already sets up pointer event handlers to achieve this “throw-scroll” behavior – ensure it is properly attached to the timeline’s scroll container.
Zooming (Ctrl+Wheel and Pinch): Implement smooth zoom in/out of the timeline, centered on the pointer location. Common UX: holding Ctrl (or Cmd) and using the mouse wheel zooms in/out. Use the useZoomScroll hook or similar logic to adjust the pixelsPerSecond scale on wheel events
github.com
. Calculate the new zoom level with bounds (e.g. min zoom 20 px/sec, max zoom 500 px/sec or as configured) and update the timeline scale state. Crucially, keep the timeline position under the cursor stable while zooming
github.com
 – i.e., if the user’s cursor is at 10s on the timeline, after zoom it should still be around 10s on the ruler. The hook’s logic (computing timeAtCursor and setting scrollLeft appropriately) handles this
github.com
github.com
. Also support trackpad pinch gestures for zoom if possible (on some browsers, pinch may be detected as ctrl-wheel or separate events). Test that zooming in/out feels fluid and that the zoom level indicator (if any) updates. Optionally, display a transient overlay showing the zoom percentage (the existing code toggles showZoomIndicator for 800ms on zoom events – you can preserve that feature).
Vertical Scrolling: If multiple tracks exceed the visible timeline height, allow vertical scrolling of the track list. This could be as simple as making the tracks container scrollable (with a scrollbar). Ensure the ruler remains on top while vertical scrolling (the ruler might need to be in a separate container or use CSS position: sticky; top: 0). For now, vertical scroll is secondary, but keep the layout flexible for many tracks.
Overall, these pan/zoom controls should make navigating the timeline fast and intuitive, mimicking the fluid feel of professional editors and design tools. The importance of momentum and smooth zoom is highlighted in the project’s goals for a polished UI
file-pudqwumq1mykte6jr31zza
, so ensure the implementation doesn’t feel jerky. All interactions should be optimized to minimize re-renders (e.g., use refs and direct DOM manipulation for scrolling where needed, as in useZoomScroll).
Fixed Playhead Overlay: Implement a playhead – a vertical line that indicates the current playback time – that stays fixed in place while the timeline content scrolls underneath. This provides a constant reference point for editing (much like the playhead in traditional NLEs). The Playhead.tsx component can be used for this: it should render a thin vertical line (e.g. 1-2px width) that spans the height of the track area
github.com
github.com
. Position it using absolute positioning in the timeline container, with its X-position = currentTime * pixelsPerSecond. Because the playhead is an overlay on the scrolling content, consider rendering it in a separate layer that does not move with the scroll (one approach: place it in the same container as the tracks, but since the tracks container is scrollable, you might instead put the playhead in an overlay div on top of the scrollable area). A simple solution is to include it inside the scrollable content but update its position on every animation frame as the content scrolls – however, truly fixing it requires separating it. For now, you can keep it in the scroll container but it will scroll; a more advanced approach is to absolutely position a line over the timeline container and update its position only when the playhead time changes (not on scroll). Style the playhead line in the accent color (bright blue, as defined by --accent token) so it’s clearly visible. It should also have a draggable handle at the top (a small triangle or knob) in future, but initially just the line is fine. Make sure the playhead can be moved via code (when the user plays or seeks, the playhead position updates). We will tie it to playback controls and keyboard shortcuts in the next feature.
Initial Keyboard Shortcut Controls: Implement a basic set of keyboard controls for timeline navigation and editing, matching common editing conventions:
J / K / L keys (Shuttle Control): These keys control playback in many video editors. Pressing L should play the video forward, J play backward, and K pause. For now, since full playback implementation might be outside timeline scope, you can simulate this by moving the playhead position: e.g., on L, start advancing the playhead to the right (forward in time) at a certain rate; on J, move it left (backwards in time); on K, stop any movement (pause). If feasible, integrate with the player if one exists (e.g., controlling an HTML5 video element or the preview component). This will make scrubbing through the timeline easier.
Arrow Left/Right (←/→): Step the playhead by small increments. Typically, left/right arrow moves one frame or one unit of time. You can assume 30fps for frame step – so one arrow press = ±1 frame = 1/30th of a second (or integrate with actual video frame if accessible). Update the playhead position accordingly (and ensure the timeline view scrolls if needed to keep the playhead in view). This allows fine-grained scrubbing.
I / O keys (Mark In/Out): Let the user mark in and out points on the timeline or clip. When I is pressed, record the current playhead time as an “In” point; when O is pressed, record it as an “Out” point. Visually, this could be represented by perhaps highlighting the section of the ruler or timeline between the in and out times. You can simply store these times in the state or timelineStore (e.g., timelineStore.inPoint, timelineStore.outPoint) and later use them for extracting sub-clips or trimming. For now, a minimal visual feedback (like a slight different background on that segment of the ruler) or console log is acceptable, but structure the code to easily add actual highlighting.
C key (Cut/Split): The C key (often mapped to the Razor tool in editing software) should split the clip at the playhead. Implement this by checking if the playhead is currently positioned over a clip on an active track; if so, perform a split: i.e., end the existing clip at the playhead time and create a new clip starting at that time with the remaining duration. This will require updating the timelineStore: you can find the clip (if any) that spans the playhead (start < playhead < end) and then use updateClip to adjust its end to the playhead, and addClip to insert a new clip with start = playhead, end = oldEnd, on the same lane (carry over other properties). Give the new clip a unique ID via the store. The timeline UI should then reflect two clips. (If no clip is under the playhead, or if the playhead is exactly at a clip boundary, C could do nothing or possibly cut all clips at that time – for simplicity, just handle the single-clip case).
Implementing Shortcuts: These shortcuts can be handled via a custom hook (like useTimelineKeyboard) or a component that attaches a keydown event listener. You can set it up so that when the timeline panel is focused (clicked) or hovered, these keys are active (to avoid capturing keys when the user is typing elsewhere). Many of these actions will interact with the player or timeline state, so ensure you call the appropriate state updates (e.g., change playhead time in state, or call functions that will manipulate clips). Also, provide user feedback: e.g., when splitting, it’s obvious because a new clip appears; for mark in/out, you might console.log or later show a small marker.
By implementing J/K/L, I/O, arrow keys, and C, we cover basic navigation and editing. These will make the timeline feel responsive to keyboard control, aligning with professional editor user experience (as noted in the project specs, keyboard accessibility is a key goal
file-pudqwumq1mykte6jr31zza
). Keep the system extensible: it should be straightforward to add more shortcuts (like spacebar for play/pause, or others) as needed.
With these foundational features in place, the timeline should be functional: multiple tracks with clips that can be dragged and trimmed, a scrollable/zoomable view with a time ruler, a playhead reference, and basic keyboard interaction. Next, ensure to follow the style and performance guidelines below to match the pro-level polish and maintainability expected.
Style & Implementation Guidelines
To achieve a professional, consistent UI and maintain high performance, follow these guidelines while rebuilding the timeline:
Use Design Tokens & Tailwind for Styling: Adhere to the project’s design system. The app uses a dark theme with predefined tokens (likely configured in Tailwind). For example, use the bg-panel-bg class for the timeline background (dark panel color) and the clip color utility classes for clip backgrounds (e.g., bg-clip-video for video clips in blue, bg-clip-audio for audio clips in pink). The accent color (bright blue, --accent) should be used for interactive highlights – e.g. the playhead line, selection outlines, or active trim handles. By using these classes/tokens, the timeline will automatically match the rest of the app’s styling and any theme changes. Also utilize Tailwind for spacing, sizing, and typography (e.g., use built-in utility classes for padding/margins instead of custom CSS when possible). This ensures consistency and speeds up development since the design language is already defined.
Responsive Layout: Make sure the timeline layout is fluid and works on different screen sizes, especially the target 13" MacBook screen (a common baseline). The timeline should occupy the bottom panel of the layout and be horizontally scrollable. If the viewport is small or resized, the timeline should still be usable: tracks might need a minimum height, and perhaps the overall timeline panel might become vertically scrollable if many tracks are present. Use CSS flex or grid for the timeline structure (the current code uses flex for aligning the left gutter and main content). Ensure that on a smaller screen, important elements (ruler, track labels, playhead) remain visible or accessible. Tailwind’s responsive utilities can be used to adjust styles at different breakpoints (e.g., font sizes on the ruler or visibility of certain labels)
file-shxvswtzmkesdt1ecpwdnp
. Test by resizing the browser to ensure nothing overlaps or breaks layout.
High-Performance Rendering: The timeline must maintain smooth performance (target 60fps, no jank during interactions). Achieving this requires conscious use of web technologies:
Favor GPU-accelerated transforms and compositing over layout-heavy properties. As noted, use transform: translateX() for moving clip elements instead of changing left or using large margins
github.com
. Similarly, avoid forcing reflows during animations – updating an element’s transform or opacity is typically GPU-optimized and won’t re-compute layout for other elements.
Batch DOM updates and expensive computations inside requestAnimationFrame loops. The existing code employs rAF for syncing scroll position and ruler updates
github.com
 and for smooth dragging in the zoom/scroll hook
github.com
. Continue this pattern: if multiple DOM writes or state updates are needed rapidly (e.g., during a drag or scroll), schedule them in the next animation frame to avoid flooding React with too many renders. Use debouncing or throttling for events like window resize or extremely fast mouse wheel movements.
Consider Canvas/WebGL for heavy drawings: If you find that rendering hundreds of DOM elements for waveforms or tick marks is too slow at high zoom levels, you can switch to drawing them on a <canvas> for better performance. The spec guide explicitly suggests using Canvas or WebGL for the timeline’s repetitive visuals (like waveforms, tick marks) while using DOM for interactive elements. A hybrid approach keeps the UI snappy – for instance, draw the audio waveform to a canvas element within the clip, rather than creating thousands of tiny divs. Ensure any canvas is high-DPI (scale by window.devicePixelRatio) so it remains sharp on retina displays
file-shxvswtzmkesdt1ecpwdnp
. This is an advanced optimization; for the initial rebuild, you might use simpler DOM methods, but keep the possibility in mind.
Use will-change or layer promotion sparingly for elements that will be animated (the Clip component already sets will-change: transform in its style
github.com
, which is good). Don’t overuse will-change on too many elements (can overload the GPU), but on key items like moving clips and the playhead it’s appropriate.
Avoid unnecessary re-renders: use React.memo for pure components (as done with Timeline, TrackRow, Clip) and selectors in the Zustand store to limit updates. For example, if the playhead position is in state, the playhead component can subscribe only to that piece of state. The timeline should not fully re-render on each tick of playback – only the playhead moves. Organize state such that each concern (clips, playhead, selection, etc.) can update independently.
Consistency and Accessibility: Leverage existing UI libraries and best practices to ensure a polished experience:
Use Radix UI components for common UI patterns like tooltips, modals, context menus, etc. For instance, if you add a tooltip that shows the precise time under the cursor on the ruler (as currently implemented with a custom span), consider using Radix Tooltip for a consistent look and accessibility support. Similarly, if you implement context menus (right-click on a clip) or any dialogs, Radix primitives can save time and ensure ARIA compliance
file-shxvswtzmkesdt1ecpwdnp
. The timeline itself should be accessible: ensure it’s keyboard navigable (e.g., tabIndex on the track container so it can receive keyboard events). Use ARIA roles or labels where appropriate (the timeline could be seen as a list of clips or a region; for now, just ensure non-text elements have labels like the Clip div has an aria-label describing its time span).
Follow the project’s coding conventions. This includes file organization (keep timeline-related hooks in the timeline/hooks folder, components in timeline/components), naming (use clear, self-explanatory names for new functions and variables), and commit structure (one feature per commit if possible, with descriptive messages). Run yarn lint to adhere to formatting/standards – fix any lint errors or warnings, including removing leftover eslint-disable comments once the code is working cleanly.
Design consistency: The timeline is part of a larger application, so make sure any new UI elements (buttons, sliders, etc.) match the established design. For example, if adding a zoom slider control (as seen in Timeline.tsx with the <ZoomSlider> component), ensure it uses the same style as other inputs (possibly the project has a styled slider or uses Radix Slider). Keep font choices and sizes consistent (e.g., timecode font might be a small monospace as used elsewhere).
No heavy external dependencies: The refactor plan emphasizes keeping the project lean and not overloading with unnecessary libraries
file-shxvswtzmkesdt1ecpwdnp
. Use the tools already chosen (React, Zustand, Radix, etc.) and avoid adding large frameworks. The goal is a maintainable codebase without bloat, which is especially important for a solo developer scenario.
Future-Proofing Considerations: While focusing on the current rebuild, be mindful of upcoming features so the architecture can accommodate them without major rework:
The timeline store should remain the single source of truth for timeline data so that it can later be replaced or synced with a collaborative backend (e.g., Yjs CRDT for multi-user editing)
file-shxvswtzmkesdt1ecpwdnp
. This means avoid local component state for things like current playhead time, selections, etc., if those might need to sync.
Structure the code in modular components (Timeline container, Track, Clip, Ruler, etc.) as described, so new features like adding a timeline canvas renderer (for advanced drawing or caching) can be introduced logically, or so that switching the clip rendering from DOM to Canvas is straightforward if needed down the line.
Keep the keyboard shortcuts handling flexible – likely more will be added (e.g., Spacebar for play/pause, or numeric plus/minus for zoom, etc.), so having a centralized mapping or a clear hook will help.
Ensure that adding touch support (pinch-to-zoom, long-press, multi-touch gestures) will be possible. For instance, the useZoomScroll hook might later be extended for handling pinch via pointer events. The current implementation already accounts for ctrlKey wheel and uses Pointer Events for dragging, which is a good start for touch compatibility. As a forward-looking note, the spec envisions a highly touch-friendly, even AI-assisted interface – our rebuild will lay the groundwork by making sure core interactions don’t assume a mouse-only input.
Document any assumptions or hacks in comments so that future contributors (or future AI agents) understand the intent. E.g., if you decide each video+audio pair uses consecutive lane indices, note that; or if certain hardcoded numbers (like default track height 48px) are used, label them clearly for easy adjustment.
By following these style and implementation guidelines, the rebuilt timeline will not only function correctly but also align with the professional UI/UX goals of the project. The result should be a clean, maintainable codebase that looks and feels like a modern video editor, and is ready for future enhancements.
Validation & Testing
After implementing the above features, verify the timeline thoroughly. Use the following checklist to ensure everything works and meets performance targets:
Local Development Preview: Run the project with yarn dev (or the appropriate start script) and open it in Google Chrome (latest version). Use a typical laptop display (for example, a 13" MacBook at 1280×800 or 1440×900 resolution in browser) as a test bed for layout. Confirm that the timeline UI loads without errors and is visible in the application’s interface (it should be at the bottom panel in the default layout). The overall layout should match the intended multi-panel design (e.g., preview above, timeline below, etc., per design docs).
Linting and Console Check: Run yarn lint to ensure code style issues are resolved. The code should pass all lint rules. Open the browser’s console and verify that there are no runtime errors or warnings when interacting with the timeline. Address any console.warn or console.error (for example, React key warnings, or any deprecation notices from libraries).
Multiple Tracks & Media Import: Test with at least two video files (with audio) to ensure multi-track functionality:
Import or add the first video – the timeline should show one video track (V1) and one audio track (A1) corresponding to this media. The clip for the video should appear in V1 and an audio clip (waveform) in A1, both starting at 0 (unless the design allows dragging from media bin). The tracks should be labeled clearly (e.g., a label "V1" on the first track’s left gutter, "A1" on the second).
Import a second video – the timeline should now expand with a new video track (V2) and audio track (A2) for the second media. The new clips should appear on those new lanes. Verify that the track labeling logic doesn’t mis-label these as audio if they are meant to be video (you may have adjusted the labeling code accordingly).
Ensure that the tracks are rendering in the correct order (typically video tracks above audio tracks if following convention). Also check that each track’s height is correct (video tracks might be taller than audio tracks as set in TrackRow).
Scroll vertically if needed – with four tracks (V1, A1, V2, A2) on a small screen, part of the timeline might overflow vertically. The UI should allow scrolling to see all tracks, or the container might expand if there is room. No track should be inaccessible.
If the media files are long, also test horizontal scrolling – add clips that extend beyond the visible timeline duration and ensure you can scroll to the end. The ruler should extend to cover the longest clip’s duration (the timelineStore.durationSec should update when clips are added).
Clip Dragging & Trimming: Check that you can manipulate clips with the mouse:
Click and drag a video clip on the timeline to a new time. The clip should move with the cursor, staying within its track lane. When you drop it, it should snap to the new position and the state should update (verify the clip’s start value in state reflects the new time). Try dragging to both left and right directions, including boundary conditions (start of timeline, or near another clip if you set up multiple clips on one track).
Drag an audio clip similarly. Audio clips likely sit in their own track, so just ensure the behavior is consistent.
Test the trim handles: hover near a clip’s start or end – the resize handle should appear (we made them visible on hover via CSS). Drag the left handle inward to trim the start – the clip’s left edge should move with your cursor, making the clip shorter, and a gap appear at the beginning of that track (or reveal whatever is behind it). On release, the clip’s start time updates (increase) and its duration decreases. Do the same with the right handle to trim the end (clip shortens from the right). Make sure you can also extend a clip if source media allows (for now, if we don’t have source length, you might allow extension indefinitely – but ideally, you prevent extending beyond the original media length if known).
After trimming, verify the waveform or thumbnail inside the clip adjusts accordingly (if implemented, waveforms should redraw or be clipped to new width; thumbnails might not need change unless you chose to show multiple frames). At minimum, the colored clip block resizes correctly and the timelineStore’s clip end value updates.
If you implemented split (Cut, via C key), also test it manually by pressing C at various playhead positions: ensure that a clip splits into two clips. After splitting, try dragging or trimming the new clips to ensure they behave independently.
Zoom In/Out and Pan: Use the controls to zoom and scroll:
With the timeline focused, hold Ctrl (Cmd on Mac) and scroll the mouse wheel up/down. The timeline should smoothly zoom in and out. Watch that the point under the cursor remains roughly steady (the content zooms centered on cursor). Zoom all the way out to the minimum and in to a high level to see that boundaries are enforced (e.g., not zooming out past min zoom where the timeline is smaller than the container, if applicable).
Observe the zoom level indicator if present (a small percentage label) – it should appear during zoom and show the relative scale (e.g., 100% at initial scale, etc.), then disappear after a moment. Check that it updates logically.
Try trackpad gestures: if on a laptop with a trackpad, perform a two-finger pinch gesture on the timeline area. The timeline should also zoom (most browsers will dispatch those as wheel events with ctrlKey, which our logic covers). Do a two-finger swipe left/right – the timeline should pan horizontally (this typically generates wheel events with deltaX or can be captured via pointer events).
Click and drag the timeline background (the area where clips are, but empty space) – the cursor should turn into a grabbing hand (ensure the CSS cursor: grabbing is applied on drag as in useZoomScroll) and the timeline should scroll as you drag, with inertia on release. Test that releasing the drag causes the timeline to continue moving slightly and then stop. Also test middle-mouse button drag if available (some implementations support both left-drag and middle-drag for panning).
While zoomed in, check that the time ruler ticks adjust: more ticks (including frame-level minors) should appear when highly zoomed
github.com
, and fewer when zoomed out (maybe only seconds or half-seconds). Scroll horizontally and confirm the ruler moves smoothly and new ticks come into view without lag.
Ensure the beat markers (if any beats data is set) line up correctly under the ruler. You could simulate beats by setting timelineStore.setBeats([1.0, 2.5, ...]) and see that a faint line appears at those seconds in the ruler.
Playhead and Keyboard Controls: Verify the playhead functionality and keyboard shortcuts:
The playhead line should be visible at time 0 initially (assuming currentTime=0). If you click on a point in the ruler (if you make the ruler clickable) or a "Go to time" control, the playhead should move there – but even if not implemented, we can test via keyboard.
Press L key: if implemented, the playhead should start moving to the right (forward in time). If you have a video preview tied in, you’d see playback start. Otherwise, just watch the playhead line – it should travel across the timeline. Press L multiple times (some editors fast-forward on multiple presses – if you implemented speed increase, check that; if not, it may just continue normal speed). Press K to stop – the playhead should stop moving. Press J to go backward – the playhead should move left. Verify that while the playhead moves, the timeline view scrolls automatically if the playhead goes past the visible area (you might need to implement follow-playhead, but if not, you can manually scroll). Ensure that no errors occur during this process and that stopping (K) truly halts the motion.
Press ←/→ arrow keys: the playhead should jump a small step left or right. At normal zoom, this may be a few pixels. Zoom in deeply (so that 1 frame = a noticeable distance) and press arrow: the playhead should move by one frame’s worth (which is visible when zoomed in). If the playhead hits the start or end of the timeline, it should just stop there (no movement beyond bounds).
Press I at some time, then O at a later time. There isn’t a built-in visual for in/out yet, but if you log or have some marker, verify that the inPoint and outPoint are stored correctly (outPoint should be greater than inPoint). You might implement a simple highlight on the ruler between I and O – check that it appears/disappears correctly when updating these points or when resetting (maybe pressing I or O again could clear or move them).
Press C while the playhead is over a clip: confirm that the clip splits. The new two clips should exactly cover the same time span as the original, divided at the playhead time. If the playhead was not over any clip, pressing C should do nothing (no error, no change). Try splitting a clip, then immediately splitting one of the results again (to see if multiple splits cause any issues). Also ensure splitting doesn’t create any overlapping clips or gaps inconsistently – each split should produce two neatly abutting clips unless the agent intentionally leaves a one-frame gap which it shouldn’t.
Try combinations: for example, start playback with L, and while it’s playing, press C at some point (simulate live cut). The behavior may be non-deterministic if not designed, but ideally it should still split at the playhead (though normally you’d pause to cut). Test quickly pressing J/K/L in succession – the system should handle quick direction changes.
Performance Monitoring: Open Chrome DevTools Performance tab and record a session of interactions (dragging a clip around rapidly, resizing it, zooming in/out quickly, panning, etc.). Look at the FPS meter and ensure that the frame rate stays high (aim for >= 45 fps even during heavy actions). There should be no big stutters or long idle frames. If you see performance drops, identify if repaint or layout is high – for example, if dragging a clip triggers layout reflow each time, then the transform approach might not be used correctly. Optimally, the timeline should mostly show composite layers moving (which is cheaper). Also monitor memory – ensure that adding/removing clips (if you tested splitting many times or undoing things) doesn’t leak (garbage collects properly). Given the relatively small scope, memory should not be a big issue, but it’s good to verify no unusual growth. The smoothness of scrubbing and dragging is a key indicator of success for this rebuild (the goal is a native-like 60fps feel
file-pudqwumq1mykte6jr31zza
).
Polish and Edge Cases: Finally, do a pass for any UI polish issues:
Check that all elements are correctly z-indexed (e.g., the playhead line renders above clips, not behind them; tooltips appear on top of everything).
If you implemented a tooltip on the ruler (showing timecode on hover), ensure it positions correctly and updates as you move the mouse. It should disappear when leaving the ruler area. If using Radix Tooltip, verify its timing and styling match expectations.
Resize the window larger and smaller to see if timeline resizes properly. No elements should break out of their containers or overlap incorrectly. On very narrow widths, you might hide track labels or shrink text to keep things usable (make sure important controls aren’t cut off).
If possible, test in another browser (Firefox or Safari) to catch any differences in wheel/pointer event handling for zoom/scroll. The implementation should ideally be cross-browser (Pointer Events and Wheel events are standard, but behavior might vary).
Ensure that after all these interactions, the application state (timelineStore, etc.) remains consistent (no duplicate clip IDs, no negative durations, etc.). Using the devtools or console to inspect the Zustand store can be helpful for this.
Verify that nothing outside the timeline was broken by these changes (e.g., if there’s a global state or context, it’s untouched). The agent should confine changes to the timeline feature.
By following this test plan, we can be confident that the timeline editor rebuild is successful. We expect to end up with a local demo that runs smoothly and demonstrates a functional, visually polished timeline with professional editor capabilities.
Reference Documents
For more context and detailed rationale behind the design and features, refer to these internal spec documents (they informed the requirements and should be aligned with our implementation):
“Motif Timeline Refactor Plan and Pro Editor UI Reskin Guide” – This document outlines the vision for refactoring the timeline UI and upgrading the design. It covers UI/UX design language (multi-track layout, panel styling) and performance recommendations. Key points include using a dark professional theme with defined color tokens (e.g. panel background, video clip tint blue, audio clip tint pink, accent blue for highlights), ensuring clear track separation and labeling, and maintaining an energetic yet clean look with accent highlights (for playhead, selection, etc.). It also emphasizes keeping the UI implementation lean (no unnecessary bloat) while adding high-impact features to approach the feel of big-name editors
file-shxvswtzmkesdt1ecpwdnp
. Our rebuild adheres to these principles (Tailwind design tokens, multi-track support, accent usage, etc.).
“Engineering Plan: Rebuilding MediaMix into a Next-Gen Browser Video Editor” – This technical plan provides the high-level goals and architecture considerations for MediaMix. It stresses real-time performance (targeting native-like 1080p/60fps playback) and a fluid UI/UX with modern interactions
file-pudqwumq1mykte6jr31zza
. Notably, it calls for momentum-based scrolling and pinch-to-zoom timeline control, as well as comprehensive keyboard accessibility
file-pudqwumq1mykte6jr31zza
 – features we implemented (using inertia on scroll, Ctrl+wheel and pinch zoom, J/K/L keys, etc.). It also suggests leveraging modern web APIs (WebGPU, WebCodecs, OffscreenCanvas) for performance
file-pudqwumq1mykte6jr31zza
. While our current rebuild uses mostly Canvas2D/DOM for simplicity, the architecture (separating rendering logic, using GPU-friendly transforms) lays the groundwork for integrating such technologies (e.g., using OffscreenCanvas for waveforms or WebCodecs for decoding in the future). The plan’s emphasis on an extensible timeline engine (potential OTIO format, CRDT for collab) is reflected in our decision to keep state in the store and actions well-encapsulated
file-shxvswtzmkesdt1ecpwdnp
.
“Innovative Browser-Based AI Video Editor: Cutting-Edge Interface Features” – This forward-looking document describes advanced features that set the product apart (many are beyond the initial rebuild, but good to keep in mind). It highlights a gesture-driven, touch-first interface (pinch, swipe, even camera-based hand gestures) for timeline interaction. Our implementation of multi-touch zoom and smooth pan is a first step toward that vision. It also discusses real-time collaboration (multiple users editing simultaneously) and AI-assisted editing (auto cuts, smart reframing). To be ready for these, our timeline is structured in a modular way with state that could be synced or augmented by AI. For example, the beats we draw could come from an AI beat-detection; a “split” command could be triggered by a natural language instruction in the future. By following solid fundamentals now, we ensure these features can be integrated later without a complete rewrite.
Each of these documents provides deeper insight into the expected functionality and future direction of the MediaMix editor. The rebuild you undertake should align with these guidelines to maximize the chance of first-attempt success and longevity of the solution. By combining the practical implementation steps in this guide with the vision from the spec docs, the agent will deliver a timeline editor that is robust, performant, and primed for the next generation of browser-based video editing.
file-pudqwumq1mykte6jr31zza
