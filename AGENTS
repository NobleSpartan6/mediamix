# Timeline Editor Rebuild Guide

This guide directs a developer or AI agent (Codex) to rebuild and polish the MediaMix timeline UI into a professional-grade video editor timeline. It breaks down the needed work into components, features, and verification steps, focusing on performance and user experience. Follow these instructions closely to implement missing features, fix broken behavior, and ensure a smooth 60fps interactive timeline.

## Scope and Focus

We will concentrate on the timeline panel of the application (the bottom editing timeline) and its state management. Key areas to address:

- **Timeline React Components:** located in `apps/web/src/features/timeline/components/`  
  - `Timeline.tsx` – the main container for the timeline (houses tracks, ruler, playhead, controls).  
  - `TrackRow.tsx` – represents a single track lane (a row in the timeline, either video or audio track).  
  - `InteractiveClip.tsx` – wraps a `Clip` component with interactive drag/resize logic (uses react-moveable).  
  - `Clip.tsx` – visual representation of a media clip on the timeline (shows waveform or thumbnail, with drag handles).  
  - Utility components: `TimeRuler.tsx` (the time scale at the top with tick marks) and `Playhead.tsx` (the vertical playhead indicator line).

- **State Management (Zustand stores):**  
  - `timelineStore.ts` – holds timeline state: clips (with their start/end times and track lanes), tracks metadata, current playhead time, in/out markers, etc. It provides methods to modify clips (`addClip`, `updateClip`, `removeClip`, `splitClipAt`, etc.). These functions must be used for all timeline edits so state stays consistent.  
  - `mediaStore.ts` – manages imported media assets (file metadata like duration, plus waveform data and thumbnails). If not fully implemented, we will create or complete it. The timeline will fetch waveform and thumbnail from here using each clip’s `assetId`.  
  - `transportStore.ts` and `playbackTicker.ts` – control playback state (playhead frame, playback rate, shuttle controls). We integrate timeline playback with these (for J/K/L keys and playhead movement).

The goal is to **reconstruct core timeline features** (multi-track support, clip manipulation, ruler, zoom/pan, keyboard controls) with clean code and high performance. We’ll rebuild any incomplete parts from scratch if needed, leveraging the above components and stores.

## Core Features to Implement

Focus on implementing the following foundational timeline features:

1. **Dynamic Multi-Lane Tracks:**  
   - **Multiple Tracks per Media:** Allow multiple tracks (lanes) in the timeline. Each imported media file with both video and audio should create two linked tracks: one video track (e.g. V1) and one audio track (A1). If a second video is added, it becomes V2 and A2, and so on. The timeline should render these tracks stacked vertically with clear labels (“V1”, “A1”, “V2”, “A2”, etc.). Use the `timelineStore.ensureTracks` logic to generate track entries up to the needed index. Adjust this logic if necessary to correctly label tracks beyond the first pair:contentReference[oaicite:75]{index=75}.  
   - **Track Height & Styling:** Video tracks should be taller than audio tracks (e.g., 48px vs 32px height, as in the current code). Maintain these differences for clarity. Implement consistent styling: e.g., use Tailwind classes `bg-panel-bg` for background, and maybe distinct background tint for video vs audio lanes if desired (currently both share panel background with a border separation). A subtle separation (1px border) between tracks is in place – ensure it remains.  
   - **Track Label Gutter:** On the left side, display track labels aligned with each track row. The code already creates a left gutter with labels:contentReference[oaicite:76]{index=76}. Ensure labels update when tracks array changes. Use track metadata (`Track.label`) from `timelineStore` for these labels rather than deriving from index parity alone. This way, if in the future we allow custom track naming or reordering, the UI will reflect it.  
   - **Audio-Only or Video-Only Tracks:** Ensure the system can handle a media asset that has only audio or only video. For example, if the user imports an audio file (MP3), it should create an audio track (A#) without expecting a video track. The `addClip` logic in `TrackRow.tsx` currently always adds two clips (baseLane and baseLane+1) on drop:contentReference[oaicite:77]{index=77}. Modify this: check the asset type (you might infer from file extension or metadata if provided). A simpler approach is to decide based on drop target – if user drags into an audio track lane, create only audio clip; if into a video lane or empty space, create both if asset has audio. The project’s scope suggests every video has audio, so this may not be urgent, but implement a reasonable check to avoid dummy second clips.  
   - **Vertical Scroll:** If many tracks are added (say more than fit vertically), the timeline track area should scroll vertically. The container in Timeline for tracks already has `overflow-y-auto`:contentReference[oaicite:78]{index=78}. Verify this works by simulating many tracks (e.g., 6-8 tracks). The ruler and track labels should remain fixed at top while scrolling vertically (use CSS `sticky` or the current layout which places the ruler outside the scroll). Test that no UI elements overlap incorrectly when scrolling.

2. **Timecode Ruler with Ticks & Beat Markers:**  
   - **Major/Minor Tick Marks:** The timeline ruler should display time graduations. Major ticks (with labels) at regular intervals (e.g., every 1 second) and minor ticks for subdivisions (e.g., frames or fractions of a second when zoomed in). Use the existing canvas approach in `TimeRuler.tsx` to draw ticks efficiently:contentReference[oaicite:79]{index=79}:contentReference[oaicite:80]{index=80}. Ensure tick spacing adapts with zoom: when zoomed out, major ticks might be 5 or 10 seconds apart to avoid crowding; when zoomed in, you can show sub-second ticks (down to frame-level if >=30px/sec). Implement a strategy: calculate an ideal interval based on `pixelsPerSecond`. For instance, if 1 sec is < 50px, consider labeling every 5 sec; if 1 sec is > 100px, label sub-seconds too. The canvas draw loop can skip or add ticks based on this.  
   - **Sticky Alignment:** The ruler should remain visible at the top as you scroll horizontally. Achieve this by drawing the canvas wider than the visible area and updating its scroll offset. In our implementation, we draw only the visible portion each frame (using `scrollLeft` to offset):contentReference[oaicite:81]{index=81}. This is efficient. Just ensure the `TimeRuler` component’s containing div spans the full width of the timeline container and has a fixed height (already `h-6`). We already sync `scrollLeft` via a custom hook and redraw on scroll:contentReference[oaicite:82]{index=82}:contentReference[oaicite:83]{index=83}. This yields a smooth moving ruler. Test that as you scroll the timeline, the ticks move correctly and the time labels at the top align with clips.  
   - **Beat Markers:** If the project provides beat timings (e.g., from audio analysis), they are in `timelineStore.beats`. These should be indicated on the ruler (and possibly across tracks). The code currently draws beat lines on the ruler canvas:contentReference[oaicite:84]{index=84}. Keep these, styling them distinctly (e.g., a semi-transparent blue line). Extend them down through the track area by drawing them in an overlay or by syncing an element in the tracks scroll container. One approach: in `Timeline.tsx`, after rendering tracks, map through `beats` and render a thin `<div>` with class `bg-accent/20` absolutely positioned at `left = beatTime * pixelsPerSecond` and `height = 100%` so it overlays all tracks. This may be simpler than messing with the canvas for full height lines. Ensure these beat lines scroll with the content (they would as children of the scroll container).  
   - **Timecode Format:** Display time labels in **minutes:seconds:frames** (or milliseconds). The helper `formatTimecode` is provided:contentReference[oaicite:85]{index=85} for HH:MM:SS.FF at 30fps. Use that for consistency. For shorter durations, MM:SS.FF is fine (hours will be 00 mostly). The font is a small monospace for clarity (already set in canvas drawing code). If any adjustments needed (like font size or color), use Tailwind or canvas fill style to match design (light gray text on dark background).  
   - **Interactivity:** Make the ruler interactive – it already has a click handler to seek the playhead:contentReference[oaicite:86]{index=86}. Preserve or enhance this: clicking on the ruler should set the playhead to that time (and maybe bring the playhead into view if follow is off – though typically we just reposition it). This is implemented via `timelineStore.setCurrentTime` in the onClick. Test it works. For hover, the tooltip shows the exact time under the cursor:contentReference[oaicite:87]{index=87}. Ensure it appears quickly and doesn’t flicker. If needed, adjust its positioning so it doesn’t overflow (if near the right edge, maybe switch `text-align: right` and anchor it accordingly – not critical).  
   - **Validation:** After implementing, manually inspect the ruler at various zoom levels: labels should be readable, ticks evenly spaced, and beat lines correctly positioned. Scroll the timeline: the ruler’s major ticks should smoothly scroll. Also check performance: drawing on scroll uses `requestAnimationFrame` – ensure it doesn’t cause lag for large timelines (the canvas drawing is quite optimized, but test with a long timeline). Use different beat patterns in `timelineStore.beats` for testing (e.g., set beats = [1, 2, 2.5, 4...] to see multiple beat markers).

3. **Clip Rendering & GPU-Optimized Positioning:**  
   - **Positioning with Transforms:** Each clip element should be absolutely positioned within its track using CSS transform for the X offset and a set width for duration. **Do NOT use** CSS left or margin for positioning, to avoid reflows. The current `Clip` component already uses `style={{ transform: \`translateX(${offset}px)\`, width: \`${width}px\`, willChange: 'transform' }}`:contentReference[oaicite:88]{index=88} – which is good. Keep that pattern. As you implement drag/resize, make sure you update those styles dynamically (via React state or refs) without forcing layout.  
   - **Clip Components:** The `Clip` component is primarily visual. It draws waveforms for audio and shows thumbnails for video (addressed later). It also contains the drag handles at left and right ends (which appear on hover via CSS):contentReference[oaicite:89]{index=89}. Ensure these handles (`cursor-ew-resize` zones) are correctly sized (we use 1px width divs that become opaque on hover). If needed, make them a bit wider (e.g., 2-3px) for easier grabbing, but still minimal so as not to always overlap clip content.  
   - **Z-index and Overlap:** Ensure that when clips are adjacent or overlapping (if we momentarily allow overlap), their stacking order is sensible. Typically, clips on higher tracks cover those on lower tracks (which naturally happens since later tracks are rendered below in DOM). Within the same track, if overlap is disallowed, we won’t have to stack. If overlaps were allowed, we’d need to decide which clip is “on top” – but since we’re avoiding overlap for now, this isn’t an issue. Just keep in mind if a slight overlap happens due to rounding, it’s usually fine as 1 frame overlap won’t be noticeable.  
   - **Performance:** A big performance win is that moving clips via transform doesn’t trigger other elements re-layout. Use `transform` for horizontal moves (already done). When resizing, changing width will cause a reflow of that element, but it shouldn’t affect others since it’s absolutely positioned. This is acceptable. Avoid any code that iterates over many DOM elements per frame or that sets style properties that affect layout (like `left`, `top`, or container widths beyond the one big content width we set). Also avoid heavy shadows or filters on many clip elements (none are specified, just noting).  
   - **Ghost/Preview Elements:** If implementing snapping feedback (e.g., a line at snap point or ghost clip), ensure they’re lightweight. We do create a portal for a snap line in `InteractiveClip` when snapping occurs:contentReference[oaicite:90]{index=90}. That’s fine. It’s just a thin line. No further action needed except to ensure it’s removed (the portal is conditional on `snapTime`).  
   - **Verification:** Add a few clips in one track and ensure they render at correct positions and lengths. Zoom in and out – their width should scale with zoom (since width in px = duration * pxPerSec). Check that rapid zoom doesn’t detach the clip from the correct time (it shouldn’t; React state ties it). Drag a clip slowly – it should move smoothly without lag; check DevTools Timeline to confirm it’s using compositing (the clip element should be on its own layer because of transform and the `will-change` hint). If any jank, investigate (likely from state updates – but we intentionally only update state on drag end).

4. **Clip Interaction: Dragging & Trimming:**  
   - **Draggable Clips:** Integrate **react-moveable** or pointer events to allow users to drag clips horizontally within their track. The existing code uses Moveable, already configured in `InteractiveClip.tsx` with `draggable` enabled:contentReference[oaicite:91]{index=91}. We will utilize that. On drag start, capture the clip’s original `start` and `end` (stored in `origin.current`):contentReference[oaicite:92]{index=92}. As the user drags (`onDrag` events), calculate the intended new start by adding the translation (in pixels) to the original start:contentReference[oaicite:93]{index=93}. Use `timelineStore.updateClip` to eventually commit the new start time in seconds. **But do not update state on every drag event** – that would re-render often. Instead, update the element’s position manually (Moveable gives us `beforeTranslate` which we apply to transform):contentReference[oaicite:94]{index=94}. This is done via the `applyTransform` helper which directly sets the element’s style:contentReference[oaicite:95]{index=95}. That keeps it smooth. On drag end, call `updateClip(id, { start: finalStart, end: finalStart + duration, lane: newLane })` to save the changes:contentReference[oaicite:96]{index=96}.  
   - **Horizontal Bounds:** Prevent dragging a clip beyond the timeline start (time 0). If the user drags left and `newStart` would be negative, clamp it to 0. Moveable doesn’t have built-in bounds for drag (except a container element, but our container is the entire scroll area which is bigger than viewport). So implement in `onDrag`: if `newStart < 0`, set `newStart = 0` and adjust `translateXRef` accordingly. The clip will then stick at the start. Similarly, you might want to prevent dragging far right beyond the timeline’s max duration – but that’s less crucial; timeline can extend if a clip is placed further. The `durationSec` in store will update to accommodate. So it’s okay to let them drag right arbitrarily (especially if they intend to create a gap).  
   - **Vertical Drag (Lane Changes):** The Moveable config has no explicit y-axis lock, and the code calculates lane changes by translateY in `onDrag`:contentReference[oaicite:97]{index=97}. This means a user can drag a clip up/down to another track. This is a nice feature to allow reordering tracks or moving clips between tracks. We should keep it, but ensure it’s logical: e.g., a video clip dragged into an audio track should probably not be allowed (we can simply revert lane if types differ). Implement a check in `onDragEnd`: if `laneRef.current` is an incompatible lane for this clip’s asset (video vs audio), ignore the lane change (i.e., use original lane instead). You can detect asset type via `clip.assetId` and `mediaStore.assets[assetId]` if there’s a type field or by checking if `asset.waveform` exists (audio) or `asset.thumbnail` exists (video). As an MVP, you might simply forbid moving between any even -> odd lane or vice versa. But if we treat all moves as allowed, ensure splitting a video/audio linked pair across different pairs might cause desync. Probably safest: **disallow cross-type moves** and only allow moving a clip to a different lane of the same type (e.g., move a video clip from V1 to V3 if there is an empty video track). This could be advanced logic; if complexity arises, you may disable vertical dragging entirely by setting Moveable’s `verticalGuidelines` or by ignoring `translateY` in calculations (the simplest hack: always reset `translateYRef.current = 0` so it snaps back). However, vertical moves *within type* can be useful (re-ordering layers). For now, we can permit vertical moves but keep the clip with its corresponding pair: e.g., if moving V1’s video clip to what would be V2, maybe also one would want to move the audio clip. That’s complex for now. So decide: easiest is to disable vertical or restrict it heavily. Given time, we’ll **restrict dragging to horizontal only** in this iteration – which matches the original plan (“no vertical move between tracks in this phase” was noted). To do that, set Moveable’s `dragArea` or handle the `onDrag` to not update lane. You can simply comment out or remove the lane calculation in `onDrag` and always use the original lane. This keeps things simple. Document this decision in code for future extension.  
   - **Resizable Clips (Trim in/out):** Enable resizing from left (in-point) and right (out-point) edges. The Moveable config has `resizable` with `renderDirections: ['w', 'e']` (west, east handles):contentReference[oaicite:98]{index=98}. On resize, similar logic: do not commit state until resize ends. Use `onResize` to update the element’s width (and position if left handle) in real-time, then `onResizeEnd` to update the clip’s start or end in state:contentReference[oaicite:99]{index=99}:contentReference[oaicite:100]{index=100}. The current code already does this: it calculates `newWidthSeconds` and updates either start or end:contentReference[oaicite:101]{index=101}. Verify that logic: when resizing from left, they update `start` by the delta and keep `end` same; when from right, they update `end` and keep `start`. This effectively trims. One thing to add: the same media duration constraint as mentioned – do not allow extending a clip beyond its source length. Implement in `onResize`: if resizing right, clamp `newEnd <= asset.duration`; if resizing left, clamp `newStart >= 0` (which we already do) and also ensure `newStart >= asset.startTime` if we ever support source in/out (not now). The asset’s full duration is the limit. If a user tries to drag out further, just stop the handle at that point (Moveable might allow overshoot visually, but on end we clamp, which will snap it back).  
   - **Snapping for Edits:** Utilize snapping for trim as well – e.g., snapping a clip edge to beats or other clip edges. The code’s `findSnap` is used for both drag and resize:contentReference[oaicite:102]{index=102}:contentReference[oaicite:103]{index=103}:contentReference[oaicite:104]{index=104}. It checks beat times and neighbor clip times. This helps align cuts. Keep this. Test that it works when trimming: e.g., if a beat at 4s, trimming a clip’s end near 4s should snap to 4s. Or trimming start to align with another clip’s end. It appears the implementation covers this by using `snapCandidates = beats + neighbor clip boundaries`. Good.  
   - **User Feedback:** As user drags or trims, provide feedback: Moveable by default shows guidelines if we set them; we already portal a snap line:contentReference[oaicite:105]{index=105}. That line appears when `snapTime` is set (meaning a snap point is found). Ensure that line covers the track area (in code it’s inserted into the track’s parent, which is the track container div, so it spans that track only). That’s okay, though ideally a snap line could span the entire timeline vertically (multiple tracks). Not critical now. Also consider highlighting the timecode or duration somewhere. For now, the zoom-level indicator area (top-right) could be used to show the current time under the cursor or length during trim, but that’s a stretch. We can skip that. Moveable might display the new dimensions if configured – it has an `onResize` event that could perhaps show something. If not, skip.  
   - **Test All Edits:** After implementing drag and trim, rigorously test: Drag clips to various positions (start, middle, end of timeline). Try dragging so two clips almost touch – feel the snap. Try creating a gap then selecting follow-playhead and playing – ensure nothing odd happens. Trim a clip’s start and end, making it very short, and very long (to the limit). If two clips butt against each other and you trim the left one’s end shorter, the right clip should not move (we’re not auto-rippling in this basic editor unless `removeClip(ripple=true)` is used explicitly). The timeline will just show a gap. That’s expected. Test splitting (C key) on a trimmed clip, etc., to see if any new bug appears (it should handle it). Also verify the internal state after many operations: no duplicate IDs, track count correct, clips’ start < end always, etc.

5. **Media Visuals: Waveforms & Thumbnails:**  
   - **Audio Waveform Rendering:** For audio clips, draw a waveform so users can see audio amplitude over time. We have an Offscreen/Offline processing in `generateWaveform` that produces an array of peaks. After importing a file, we store that in `MediaAsset.waveform`. The `Clip` component uses a `<canvas>` to draw the waveform when it mounts or resizes:contentReference[oaicite:106]{index=106}:contentReference[oaicite:107]{index=107}. Optimize this drawing: ensure it uses the peaks array efficiently. The current code iterates over each pixel width, sampling the corresponding peak, and draws a line. This is O(width) which is fine (at 100px/sec, a 10s clip is 1000px, trivial). If a clip is extremely long, this could be thousands of pixels – still manageable, but keep an eye. We already clear and draw in one path stroke. Good. If performance becomes an issue, we could pre-render part of the waveform to an image or further downsample. Not needed unless profiling shows a hotspot.  
   - **Waveform Update on Zoom:** One subtlety – if zoom changes, the clip width changes, and we redraw via ResizeObserver. This means the waveform will stretch or compress. Ideally, one might want to re-sample peaks for new resolution to avoid aliasing. However, since we have a dense peak array, scaling it linearly is fine. It might appear a bit “chunky” if zoomed a lot because we only draw lines at pixel granularity – but that’s acceptable. So the approach stands. Just verify that resizing the timeline (zoom in/out) indeed triggers the canvas redraw (the observer should catch width changes). If not, we might need to also watch the `pixelsPerSecond` prop in the effect dependencies. The code doesn’t include `pixelsPerSecond` or `clip.end-clip.start` in the effect, it only uses `asset.waveform` and `type`:contentReference[oaicite:108]{index=108}:contentReference[oaicite:109]{index=109}. The ResizeObserver handles width, so we’re fine.  
   - **Video Thumbnails:** For video clips, display a thumbnail image. The approach implemented takes a captured frame (likely the first frame) and sets it as a background image on the clip div:contentReference[oaicite:110]{index=110}. This is done through `asset.thumbnail` (a data URL or blob URL). Ensure that `captureThumbnail` is called during import (it appears in `VideoImportButton.tsx`). Once a clip is added and asset in store, the thumbnail should be present. The Clip component picks it up via `useMediaStore` selector:contentReference[oaicite:112]{index=112}. That means it will rerender when the asset is added (since initially asset might not be there, then after import it is). This should update background nicely. Test it: import a video, see if the timeline clip immediately shows an image. If not, maybe the asset is added after the clip, causing a race. To handle this, we might add a slight delay or ensure that when `addMediaAsset` runs, it first calls `mediaStore.addAsset`, then `timelineStore.addClip`. In our test environment, we manually add asset then clip, which seems done. We’ll assume that’s sorted out (the test file did exactly that). If there’s a glitch (like clip appears, then thumbnail pops in a moment later), that’s acceptable for now.  
   - **Thumbnail Sizing:** As noted, a single thumbnail stretched over a long clip can be blurry. For now, it’s okay – it still gives an idea of content. We won’t implement multi-thumbnail strips in this phase. But as a minor tweak, if a clip is very long (say >10s), perhaps repeat the thumbnail to fill (CSS `background-repeat: repeat-x` with `background-size: contain` could tile it, but that might look weird). Alternatively, we could just center the image (the default cover might zoom it in a bit). We’ll leave it. Just document this as a known limitation in comments for future enhancement.  
   - **Media Store Integration:** Double-check the `mediaStore` usage: when dropping an asset onto timeline (TrackRow.onDrop), we use the asset’s duration from `assets[assetId]`:contentReference[oaicite:113]{index=113}. That means the asset must exist in `mediaStore.assets` by then. Ensure that whenever a media is imported (via the Import button or other mechanism), we call `useMediaStore.getState().addAsset`. The test code does it, but in real UI, after selecting a file, you should add to mediaStore then add clips. The `VideoImportButton` seems to call a legacy `addMediaAsset` and then also does `useMediaStore.getState().addAsset` (perhaps duplicative). We’ll assume the asset info is there. If not, TrackRow’s drop will no-op. In development, test by simulating drop events or integrating with the import flow.  
   - **Edge Cases:** If waveform generation fails or is too slow (for a large file), the asset.waveform might be empty. Our Clip drawing code will just skip drawing if no peaks:contentReference[oaicite:114]{index=114}. That’s fine (it leaves a blank clip). Maybe show a waveform icon or something if empty – optional. If thumbnail extraction fails, we just get the colored block (bg-clip-video). That’s fine too.  
   - **Testing:** Use a sample video with audio. After import, timeline should show a video clip (blue background with a frame image) and an audio clip below it (pink background with waveform). Verify the waveform roughly matches the audio (e.g., silent parts flat, loud parts spiky). Move the clips around, trim them – the waveform canvas should update its width accordingly (the content of the waveform will not change since we don’t currently adjust for trimmed in-point offset – it always draws from asset start. In future, we might want to only show the portion of waveform corresponding to the clip segment, but that requires slicing the data. For now, a trimmed clip still shows waveform from time 0 which is slightly inaccurate if trimmed start >0. Mark this as a potential improvement but out of scope now). Check memory usage by adding multiple clips – the canvas elements should not leak (they are freed on clip unmount). Also ensure that re-importing or removing assets clears out data (if you implement remove, not priority).  

6. **Playback & Playhead Integration:**  
   - **Playhead Display:** Implement a persistent vertical playhead line that stays at the current playback time. The `Playhead` component draws a thin line and is already included in `Timeline.tsx`. We must fix it to remain in place while content scrolls (see bugfix above in the audit). After fixing scroll sync, the playhead line will act as an overlay at `currentTime`. Style it with the theme accent color (should already use `bg-accent`). Optionally, add a small handle at the top of the line (common in editors, looks like an inverted triangle or arrow) – you can create this with CSS border or an SVG icon. Not crucial, but mention for polish. Ensure the playhead’s z-index is above clips so it’s always visible.  
   - **Synchronization with Video Preview:** In a full app, the playhead time would tie to the video preview player. We might have a video element playing that updates `playheadFrame` (via `playbackTicker`). In our test environment, we don’t have actual video playback, but the architecture is ready: `transportStore.playheadFrame` is incremented during playback, and `Timeline` converts that to seconds and sets `timelineStore.currentTime`. If there is a `VideoPreview` component, it likely listens to currentTime or playheadFrame as well. For now, focus on timeline’s side: ensure that when `currentTime` updates (via keyboard scrub or playback), the playhead line moves accordingly. This is largely done – verify the effect in `Timeline.tsx` that scrolls on playhead changes with follow mode:contentReference[oaicite:115]{index=115}.  
   - **Keyboard J/K/L:** As implemented, these keys control `transportStore.playRate`. When L or J is pressed, `playRate` goes to ±1, ±2, etc., and the playbackTicker starts nudgeFrames. This effectively moves playheadFrame forward/backward. The timeline observes playheadFrame (via useTransportStore) and updates currentTime. All good. We should ensure that actual video playback (if any) is also controlled. If there’s a `<video>` element, perhaps `transportStore` is also linked to that. Not in our scope here, but keep architecture such that if an external video player sets currentTime, we’d want to update timeline (maybe using `setCurrentTime`). That could be future work – just note it.  
   - **Manual Scrubbing:** Implement the ability to click on the timeline (background or ruler) to reposition playhead (already done on ruler click) and possibly drag the playhead to scrub. Dragging the playhead is advanced; if time allows, implement a simple version: when the user clicks on the playhead line or a special draggable area at top of it, capture pointer and on move, calculate new time = previousTime + pixelDelta/pxPerSec, update currentTime accordingly. This would allow scrubbing through timeline by dragging the playhead. It’s a nice touch but optional for MVP.  
   - **Follow Mode:** Ensure the “Follow” toggle (Follow/Unfollow button in top-right controls) works. When Follow is ON, during playback the timeline should scroll automatically so the playhead stays roughly center or within view. The code does this by adjusting scrollLeft if playhead is near edges:contentReference[oaicite:116]{index=116}. Test: turn follow on, press L (play forward) and watch when playhead nears right edge – timeline should start scrolling. Turn follow off, playhead will eventually move off-screen and timeline stays put. That’s correct. The button text toggles between “Follow” and “Unfollow”:contentReference[oaicite:117]{index=117} – ensure that state toggling via `setFollowPlayhead` works and that it reflects in the UI.  
   - **Edge Conditions:** Stopping playback (K or Space) doesn’t recenter anything – it just leaves playhead where it is. That’s fine. If the user manually scrolls while paused, the playhead might go off-screen; that’s fine because follow is likely off in that scenario. If follow was on and playback stopped, follow can remain on (so if playback resumes, it will scroll again). All good.  
   - **Testing:** Simulate playback by holding L (the playhead will start moving). Watch the playhead line move smoothly. It should not flicker or jump (it increments by `rate * (1/30) sec each tick, so ~0.033s at 1x, which is a bit coarse for 60fps visual movement – you might see slight stepping if the line moves in 3px jumps at 90px/sec, but that’s acceptable for now). If we wanted perfect smoothness, we’d tie it to real time or video frame callbacks – out of scope. At 1x it’s fine. Increase speed (press L multiple times) – the playhead should accelerate. Check that the timeline auto-scrolls appropriately. Test backward (J) as well. Then test the accuracy: press K to stop, and see if the playhead line stops exactly where expected. Use arrow keys to nudge frame by frame – verify the movement is exactly one frame (at 30px/sec, one frame = 1px movement; you might need to zoom in a lot to observe). Mark In/Out (I/O) while playing and while stopped to see that it captures the time. Use the follow toggle during playback (turn it off mid-play and see timeline stop scrolling, turn on and it jumps). Everything should feel responsive and without error.  

7. **Keyboard Shortcuts & Accessibility:**  
   - **Implemented Keys:** We have J/K/L, I/O, C, ←/→, and Delete implemented. Add Space (play/pause) as discussed. Also consider adding **Home** and **End** keys to quickly jump playhead to start or end of timeline. This is easy: on Home (code 36) set currentTime = 0; on End (35) set currentTime = timelineStore.durationSec (last clip end) or outPoint if set. It’s a common shortcut for video editing. Implement if straightforward.  
   - **Prevent Conflicts:** Ensure our keydown handler is not active when the user is focused on a text input or other element. Since we attach to window, it will fire regardless. Perhaps we should scope it when timeline is focused/hovered. Simpler: check `document.activeElement` – if it’s an input or contenteditable, return early to not override typing. This prevents, for example, pressing “Space” in a text field from toggling playback. Implement this check in `handleKeyDown`. Alternatively, only add the listener when timeline panel is in focus. The current hook attaches unconditionally:contentReference[oaicite:118]{index=118}:contentReference[oaicite:119]{index=119}. We can refine: add a `tabIndex` to the timeline container and onFocus attach, onBlur detach. This might be overkill for now but note it. At minimum, do the activeElement type guard.  
   - **Screen Reader / ARIA:** While a full accessibility pass is beyond scope, add basic ARIA roles/labels where trivial. For instance, the timeline region could have `role="group"` with `aria-label="Timeline editor"` so it’s announced. Clips have `aria-label` in code describing their start-end times:contentReference[oaicite:120]{index=120} – that’s nice. Perhaps include asset name too: e.g., `"Clip '${asset.fileName}' from 0:00:00.00 to 0:00:05.00"`. Use whatever info is available. These labels help if the app ever gets screen reader navigation. It’s low effort to include.  
   - **Testing Shortcuts:** Make sure none of the keys cause browser defaults that interfere. We already call `e.preventDefault()` for most in the switch. Ensure Space will prevent page scroll. Arrow keys already prevent default to avoid scrolling the page when timeline is focused. Confirm that holding down arrow key continuously moves playhead frame-by-frame (the keydown will auto-repeat; our handler will be called repeatedly – this should nudge multiple frames smoothly). Check that pressing C with no clip under playhead does nothing (and doesn’t error). If multiple clips under playhead (shouldn’t happen without overlap), our code splits the first it finds – that’s okay.  
   - **Non-QWERTY or modifiers:** Unlikely needed now, but note that keys like J/K/L are universal enough. We use lowercase in code and also check uppercase by duplicating cases – it might be simpler to do `e.key.toLowerCase()` once. It’s fine as is.

8. **UI Polishing & Dev Testing:**

   - **Tailwind & Design Consistency:** Use the established design tokens for all styling. Our timeline uses classes like `bg-panel-bg` (dark gray background), `text-gray-300` for minor text, `border-white/10` for faint borders, and `bg-accent` for highlights (accent likely a blue). Continue using these to ensure the timeline matches the rest of the app’s look. All new UI elements (e.g., any added buttons or sliders) should conform to the design system or use existing components (`Button`, etc.). For example, the Follow toggle uses a secondary Button styling. The ZoomSlider is presumably a styled input; use it as is (make sure it’s placed correctly and works to zoom when dragged).  
   - **Layout and Responsiveness:** Verify the timeline fits well in the overall app layout. On a typical 13” laptop screen, the timeline panel might be around 300-400px tall. Ensure with multiple tracks that everything scrolls nicely and the ruler stays on top. If the app is resizable, test shrinking the window: track labels might squish – they are short like “V1” so fine. The Zoom slider and buttons at top-right should not overlap the content – currently they’re absolutely positioned:contentReference[oaicite:121]{index=121}. Check that at very small widths, those controls are still accessible (they might overflow out of the panel if not careful). If needed, adjust their container or use a flex layout at top-right.  
   - **No Overflow/Scrollbars Except Intended:** The timeline track area should only show a horizontal scrollbar (for timeline content) and vertical scrollbar (for track list) as needed. There should be no unexpected scrollbars on the overall page when timeline is present. If you see any, likely a CSS issue (maybe the absolute positioned playhead or snap lines extending beyond a container). Fix by containing overflows or adjusting positioning.  
   - **Dev Environment Tips:**  
     - Run `yarn dev` to start the app in development mode. The timeline is part of the main interface. Load up some media files to populate it (the app likely has an import button or drag-and-drop for files – use the `VideoImportButton` in the UI).  
     - Have the browser console open to catch any errors or warnings. Address them – e.g., React key warnings, prop type warnings, etc.  
     - Run `yarn lint` (or `yarn format` if applicable) after making changes to ensure code style consistency. Fix any lint issues (the codebase may have ESLint rules – adhere to them, including removing any `eslint-disable` comments that are no longer needed).  
     - Run `yarn test` (if a test script is available) to execute unit tests. The repository has some tests for timeline (e.g., drag/drop, interactive clip). Update those tests if our changes alter their assumptions (for instance, if we disabled vertical dragging, a test expecting lane change might need adjustment or skipping). All tests should pass before finalizing.  
   - **Performance Monitoring:** After implementing, use Chrome’s Performance tab to record some interactions (dragging, zooming, playing). Aim for the timeline interactions to run at 60fps with no dropped frames. Look at the timeline: the majority of frames should have idle time. If any heavy operation shows up (long tasks >16ms), identify and optimize as discussed. Especially check drag – it should be mostly GPU work. Also monitor memory: ensure no continual increase as you add/remove clips (the tests resetting stores help here).  
   - **Cross-Browser Check:** Test the timeline in at least one other browser (Firefox or Safari) if possible. Pay attention to pointer event behavior (Safari might treat trackpad differently, for example). The polyfilled pointer events should cover Safari. Ensure the basic features work (drag, zoom keys). If something like Ctrl+wheel doesn’t zoom in Safari (which doesn’t send ctrlKey on pinch), consider adding alternative event (Safari might treat pinch as `gesturechange` events – we can skip that for now as pinch often triggers wheel+ctrl on Mac Chrome but not Safari). It’s an edge case; just note if something is off.  

## Validation & Testing Checklist

Use this checklist to verify that all features are working and polished:

- **Basic Load:** Start the app and ensure the timeline renders without errors. It should initially be empty (or showing an empty track area). No console errors.

- **Media Import and Track Creation:** Import one video file (with audio). Verify: A new video clip appears at the start of timeline on track V1, and an audio clip on A1 beneath it. The track labels “V1” and “A1” are visible. The video clip shows a thumbnail (or colored block if thumbnail generation is slow), the audio clip shows a waveform (or flat line if not yet generated).  
  Import a second video file. Expected: new tracks V2 and A2 are created below, with that file’s clips at start of those tracks. Track labels update to include V2, A2. No mix-ups (like mislabeling A2 as A1, etc.). All four tracks are scrollable vertically if they don’t fit.  
  Import an audio-only file (if available, e.g., an MP3). Expected: a single audio track A3 appears with the waveform clip. No video track for it. (If our logic doesn’t yet differentiate, it might create a “V3” with no clip – if so, that’s a bug to fix by only adding audio clip for audio asset).  
  Check that timelineStore.tracks array length matches what you see (use devtools or add a console.log after imports).

- **Clip Dragging:** Drag the first video clip (V1) to the right by a couple of seconds. It should move to a new time (e.g., to 2:00 if you dragged that far). On drop, it stays there. The audio clip on A1 should ideally remain in place (since we didn’t implement linked dragging of both). In our current setup, dragging V1’s clip does not automatically drag A1’s clip. This means you can desync them. That’s a feature to improve later (grouped dragging). For now, it’s okay – user can manually move the audio to match. (Document this limitation if needed.)  
  Try dragging the audio clip on A1 – move it to start at 1s, drop it. Works similarly.  
  Try snapping: drag V1 clip so its start aligns with A1 clip’s end. You should feel it snap and see the blue snap line. On drop, check the times – they should match exactly (no gap).  
  Try to drag a clip to negative time (far left) – it should stop at 0s.  
  If vertical drag is enabled: try dragging V1 video clip downward. If we didn’t disable it, it might move to V2 track. If allowed, ensure it drops correctly in timelineStore (clip.lane changes to 2). Check that tracks array doesn’t duplicate incorrectly (it should already have V2 track, so fine). If we disallowed vertical, then the clip should ignore the vertical movement (stays on V1).  
  Check overlapping: drag V1 video clip and drop it so it overlaps the V1 audio clip in time (i.e., same lane overlap, which is not possible in same lane, since V1 audio is separate lane, okay). Try overlapping two clips on the same track (if you have two clips on V1 track, e.g., split one clip and then try to drag the second over the first). Our code should prevent overlap (either by snapping or just allowing overlap visually). Ideally, verify that one cannot place two clips at same time on one track (they should snap adjacent). If you manage to, see if any rendering issues (they will simply overlap in DOM, last one likely on top). Since we aimed to prevent it, this shouldn’t happen.

- **Clip Trimming:** Hover over a clip edges to see trim handles. Drag the right edge of the first video clip to the left, trimming its duration shorter. As you drag, waveform (if any) and thumbnail will scale accordingly. Drop it at some point. The clip now ends earlier. The gap after it is visible or next clip fills it if there was one right after. The timelineStore.clipsById for that clip should have a smaller `end`.  
  Drag the right edge out to the right (extend). If the asset has that length available, it should extend until you hit the original media duration. If you try to go beyond, it should stop. Verify by how far you can extend (compare to media duration from asset info).  
  Trim the left edge similarly (make the clip start later). After trimming start, the clip’s waveform currently does **not** shift content (it still shows from beginning of audio) – so the waveform might not reflect the actual audio segment precisely. That’s acceptable for now, but note it. The clip’s start in timelineStore updates (increases). If there was another clip butt to its left, a gap will appear (we do not ripple delete).  
  Ensure that trimming one clip doesn’t accidentally affect neighboring clips or tracks (shouldn’t).  

- **Splitting Clips:** Select a clip (or just position playhead over it) and press **C** (Cut). The clip should split into two at the playhead position. Verify: two clips now exist on that track, their start/end adjusted. No gap between them (end of first = start of second = cut time). Both clips should retain the same assetId as original. If the original had a waveform/thumbnail, both should show it (they’re sharing the same asset but display full waveform – again, waveform won’t visually indicate the cut, but that’s fine).  
  Check timelineStore: a new clip object with a new id should be added, track count stays same.  
  Try splitting at clip boundary (e.g., exactly at clip start or end) – our function might do nothing. That’s okay. No error should occur.  
  Try splitting while playing (if you can manage the timing) – it should still cut (maybe a slight offset if playhead moved, but fine).  
  After splitting, drag or trim the new clips to ensure they behave independently.

- **Keyboard Shortcuts:**  
  Press **L** to play forward. The playhead should start moving. If a video preview is present, it should play; if not, at least the playhead moves. Press L again – playhead moves faster (2x). A third time – faster (4x). The speed changes should be noticeable (if preview video was there, you’d see it; with just timeline, the playhead speed is our clue). Press **J** to reverse – if at positive speed, first J press likely sets -1x (reverse normal speed). Multiple J presses increase reverse speed similarly. Press **K** to pause – playhead stops. Press **K** when paused does nothing (which is fine).  
  Press **←/→** arrows: playhead should move a tiny step. At 30fps timeline, that’s 1 frame ~0.033s. It may be a barely visible move unless zoomed in. Zoom in deeply and try – you’ll see it jump frame by frame. Holding arrow key should move repeatedly (check that it doesn’t overshoot weirdly – it should just step continuously).  
  Press **I** at some time – mark in. **O** later – mark out. Observe the highlighted region on ruler (light blue overlay between in/out). Press I again somewhere else – should redefine in (the highlight updates). Possibly test clearing by pressing I or O when no counterpart is set (our code doesn’t explicitly clear if same pressed twice – could add that later).  
  Press **Space** (we implemented toggling): if paused, it should start playing (likely at 1x forward); if playing, it should pause. Ensure this mirrors K’s behavior. Check that spacebar doesn’t scroll page or click a button (preventDefault should cover it).  
  Press **Delete** with a clip selected (you might need to implement selection – currently clicking a clip sets it selected in state). The code does maintain `selectedClipIds`. When you click a clip, it adds it to selection (and with Shift/Ctrl you can multi-select):contentReference[oaicite:122]{index=122}. Test: click one clip (it should get an outline indicating selection), then press Delete – it should be removed. Multi-select: shift-click another clip (two are selected, each should have outline), press Delete – both removed. Check that `removeClip` with multiple deletion handles track pruning properly (store’s removeClip doesn’t directly handle multi, but we call removeClip for each). The tracks pruning after each remove might shorten tracks early. In our implementation, we call removeClip for each selected in a loop:contentReference[oaicite:123]{index=123}. This could potentially drop a track out from under the second clip if we removed the only clip on a higher track first. E.g., if V2 and A2 have one clip each and both selected, deleting V2’s clip might prune tracks removing V2/A2, then deleting A2’s clip might fail because track no longer exists. This is a corner case. If such a scenario arises, consider refining removal (maybe remove all selected then prune once). For now, test and see if anything breaks. If so, handle accordingly (e.g., sort deletions by lane desc so higher lanes removed first or vice versa – honestly, better to remove without pruning until after all done; a quick fix: set `timelineStore.setState({ clipsById: { ... } })` manually for all removed, then call pruneTracks once – but that’s too deep; simpler: disable track pruning in removeClip by calling it with ripple options and then after loop do a single `timelineStore.setClips(Object.values(clipsById))`. Given time, this can be improved if needed).  
  Other keys: make sure no other debug keybindings are accidentally active (like something triggering from an old snippet – unlikely).  

- **Zoom & Pan Interactions:**  
  Use the **ZoomSlider** (UI element at top-right) – drag it or click to zoom in/out. Confirm it updates `pixelsPerSecond` in Timeline (the clips resize, ruler ticks change). The Zoom % indicator should appear while changing and disappear after ~0.8s. Good.  
  Use **Ctrl + Mouse Wheel** over the timeline: zoom in/out smoothly. Test centering: place mouse over 10s mark, zoom in – 10s stays roughly at cursor. This indicates the logic working:contentReference[oaicite:124]{index=124}:contentReference[oaicite:125]{index=125}. Test zoom limits: it shouldn’t zoom out beyond min (if you try, it likely stops or feels resistant).  
  **Two-finger pinch** on trackpad: this should also zoom (on Mac Chrome it triggers ctrl+wheel events, on Safari it might not without specific handling). If you can, test on a Mac Safari – pinch might zoom the page instead (if not handled). This could be a known limitation. At least document that Chrome/Firefox are best for pinch zoom for now.  
  **Scroll (Pan):** Use **mouse wheel** normally (vertical scroll) – if horizontal scroll bar is present, vertical wheel typically does nothing or scrolls page. Our code listens for altKey or deltaX to treat as pan:contentReference[oaicite:126]{index=126}. So, try **Shift + Wheel** (which usually sends deltaX in some browsers) – timeline should pan. Also try **Alt + Wheel** – timeline should pan (our code sets `panDelta` for altKey). If on a Mac, a magic mouse or trackpad will send horizontal scroll naturally with two-finger swipe – test that (should pan timeline).  
  **Click-and-drag pan:** If we left it enabled, clicking empty space and dragging should move timeline (with a grabbing cursor). Try dragging timeline background – it should scroll (with inertia on release). If we disabled left-drag pan in favor of space-drag, then test **Space + drag**: hold space, click and drag – it should pan (if implemented). Middle-click drag (if you have a mouse with middle button) – that should pan as well (we allow button 1 in handler):contentReference[oaicite:127]{index=127}. If you can’t easily test middle, it’s okay.  
  Check **inertia:** fling the timeline (drag quickly and release). It should continue moving and gradually stop. Feels nice. Make sure it doesn’t overshoot too far (if it does, not a big problem, it’ll just stop at scroll max or min due to no content).  
  **Vertical scroll:** If multiple tracks, try scrolling vertically (e.g., with mouse wheel when pointer over track list). That should scroll the track list area. The ruler (6px high bar) should remain at top (if it scrolls off, that’s a bug – fix with sticky). Likely fine since we separated containers.  
  Throughout zoom/pan, ensure the **playhead line** stays put (after our fix). Zooming shouldn’t affect playhead relative position (it recalculates transform each render, so it should move if currentTime changed, but zoom itself doesn’t change currentTime, so playhead stays at same time coordinate which in pixels will shift relative to content – but since we subtract scroll, it remains fixed). Check by centering playhead in view, then zoom in – playhead line should still align with the same time under it, meaning content scales around it (this is tricky to notice without a reference; alternatively, ensure the playhead time does not change on zoom – it shouldn’t).  

- **Miscellaneous:**  
  - No errors in console during any of these actions. If something appears (like “Cannot update unmounted component” or prop type warnings), address them.  
  - Ensure all state updates are correct (use the browser Redux/Zustand devtools if available or logs). For example, after all tests, if you print timelineStore, it should have accurate `durationSec` (equals max clip end, which should be the end of the last clip on the highest track). Check that `durationSec` updates when you move or trim a clip that extends the timeline shorter or longer:contentReference[oaicite:128]{index=128}. The UI uses `duration` prop for TimeRuler and content width – verify that is derived from state properly (likely `duration = useTimelineStore(s=>s.durationSec)` passed to TimeRuler and container width). It should update as clips move. Test: move a clip beyond the current end – timeline should extend (scroll width increases, ruler extends ticks). Delete or trim the clip that was the furthest right – timeline should shrink (durationSec recalculated).  
  - UI feedback: ensure selection outline (blue border) appears when clicking a clip and disappears when clicking elsewhere. Ensure the `Follow` button indicates state correctly.  
  - Clean up: remove any `console.log` or debug code before final commit. Ensure no lingering `eslint-disable` unless necessary (the code had some ts-ignore for moveable events – that’s fine to keep if needed).  
  - **PR Preparation:** When all the above is working and tested, prepare to commit. Follow the project’s git guidelines: likely small commits per feature or one commit if it’s an atomic change. Use clear commit message(s), e.g., “Implement timeline multi-track, drag & drop, and keyboard controls” or break it down by feature. Then open a Pull Request, describing what you did, referencing this guide’s requirements. Make sure to run all tests (if any) and linters one more time.
